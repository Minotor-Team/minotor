package impl

import (
	"crypto"
	"encoding/hex"
	"fmt"
	"math/rand"
	"sync"
	"time"

	"go.dedis.ch/cs438/datastructures/concurrent"
	"go.dedis.ch/cs438/peer"
	"go.dedis.ch/cs438/types"
	"golang.org/x/xerrors"
)

type RouteNode struct {
	*UserNode
	Profil *peer.SocialProfil
}

type RouteManager struct {
	RoutingTable *SocialRoutingTable
	// Stores the public key of a suspect at the tail
	KeyStore concurrent.Map[string, string]
	// Stores the tail of a route by id.
	TailStore           concurrent.Map[uint, types.Edge]
	NotificationService peer.NotificationService[uint, string]
}

func NewRouteManager(routeSeed int64, socialProfile peer.SocialProfil) *RouteManager {
	return &RouteManager{
		RoutingTable:        NewSybilRoutingTable(routeSeed, socialProfile),
		KeyStore:            concurrent.NewMap[string, string](),
		TailStore:           concurrent.NewMap[uint, types.Edge](),
		NotificationService: NewNotificationService[uint, string](),
	}
}

func (r *RouteManager) Reset() {
	r.KeyStore = concurrent.NewMap[string, string]()
	r.TailStore = concurrent.NewMap[uint, types.Edge]()
	r.NotificationService.Close()
	r.NotificationService = NewNotificationService[uint, string]()
	r.RoutingTable.Reset()
}

// Create a new RouteNode with an provided social network.
func NewRouteNode(user *UserNode) *RouteNode {
	node := &RouteNode{
		UserNode: user,
		Profil:   &user.routeManager.RoutingTable.socialProfil,
	}

	return node
}

// Executed by each suspect:
//
// 1. Select a random neighbor y.
//
// 2. Sends a ForwardRouteMessage to y.
//
// This function is blocking. It waits for the route to be completed.
//
// Each route need to have an id. This id is used to identify the route (to differentiate the routing permutations).
// It must be unique for each route, and in the range [1, r] for the verifier (as there is a mapping with the balance).
func (n *UserNode) StartRandomRoute(budget uint, id uint, timeout time.Duration, mustRegister bool) (string, error) {
	neighbor, ok := n.routeManager.RoutingTable.GetRandomNeighbor()
	if !ok {
		return "", xerrors.Errorf("StartRandomRoute{id: %v}: No neighbor to start random route", id)
	}

	key := n.getKey()
	err := n.sendRoute(budget, budget, key, id, neighbor, false, mustRegister)
	if err != nil {
		return "", xerrors.Errorf("StartRandomRoute{id: %v}: %v", id, err)
	}

	// Wait for the route to be completed
	tail, err := n.routeManager.NotificationService.Wait(id, timeout)
	if err != nil {
		return "", xerrors.Errorf("StartRandomRoute{id: %v}: %v", id, err)
	}
	return tail, nil
}

// Build the route and sends it.
func (n *UserNode) sendRoute(routeLength uint, budget uint,
	key string, id uint, dest string, reversed bool, mustRegister bool) error {

	mac, err := n.computeMAC(budget, key, id, dest)
	if err != nil {
		return xerrors.Errorf("failed to compute MAC: %v", err)
	}
	routeMessage := types.RouteMessage{
		Length:       routeLength,
		Budget:       budget,
		Data:         key,
		MAC:          mac,
		ID:           id,
		Reversed:     reversed,
		MustRegister: mustRegister,
	}

	msg, err := n.conf.MessageRegistry.MarshalMessage(routeMessage)
	if err != nil {
		return xerrors.Errorf("Failed to marshal message: %v", err)
	}

	err = n.Unicast(dest, msg)
	if err != nil {
		return xerrors.Errorf("Failed to unicast: %v", err)
	}
	return nil
}

// Return the node public key.
// It corresponds to its address.
func (n *UserNode) getKey() string {
	return n.conf.Socket.GetAddress()
}

// Compute a basic MAC to conform to the paper.
// The MAC is computed as follows:
// MAC = SHA256(Budget || Key || ID || SharedKey)
func (n *UserNode) computeMAC(budget uint, key string, id uint, dest string) (string, error) {
	sharedKey, ok := n.routeManager.RoutingTable.GetSharedKey(dest)
	if !ok {
		return "", xerrors.Errorf("computeMAC: Cannot compute the MAC without a shared key with %v", dest)
	}
	h := crypto.SHA256.New()
	h.Write([]byte(fmt.Sprint(budget)))
	h.Write([]byte(key))
	h.Write([]byte(fmt.Sprint(id)))
	h.Write([]byte(sharedKey))
	hash := h.Sum(nil)
	mac := hex.EncodeToString(hash)
	return mac, nil
}

const MIN_BUDGET uint = 1

func (n *UserNode) PropagateRandomRoute(msg types.RouteMessage, sender string) error {
	mac := msg.MAC
	budget := msg.Budget
	data := msg.Data
	id := msg.ID
	routeLength := msg.Length
	expectedMAC, err := n.computeMAC(budget, data, id, sender)
	if err != nil {
		return xerrors.Errorf("PropagateRandomRoute failed to compute MAC: %v", err)
	}
	if budget < 1 || budget > routeLength || mac != expectedMAC {
		return nil // Discard the message
	}

	if budget == MIN_BUDGET {
		// The message has reached its destination
		// If the message was a forward route from a s-instance, we need to register the public key
		// under the name of the edge.
		if !msg.Reversed {

			edge := types.Edge{From: sender, To: n.getKey()}
			edgeData := edge.String()
			if msg.MustRegister {
				publicKey := data
				n.routeManager.KeyStore.Add(edgeData, publicKey)
			}

			err := n.sendRoute(routeLength, routeLength, edgeData, id, sender, true, true)
			if err != nil {
				return xerrors.Errorf("PropagateRandomRoute: failed to reply with a reversed route: %v", err)
			}
		} else {
			tail, err := types.ParseEdge(data)
			if err != nil {
				return xerrors.Errorf("PropagateRandomRoute: the data {%v} received should be an edge", err)
			}
			n.routeManager.TailStore.Add(msg.ID, tail)
		}

	}
	nextHop, err := n.nextHop(msg, sender)
	if err != nil {
		err = n.sendRoute(routeLength, budget-1, data, id, nextHop, msg.Reversed, msg.MustRegister)
		if err != nil {
			return xerrors.Errorf("PropagateRandomRoute: %v", err)
		}
	}
	return nil
}

func (n *UserNode) nextHop(msg types.RouteMessage, sender string) (string, error) {
	id := msg.ID
	reversed := msg.Reversed
	hop, err := n.routeManager.RoutingTable.GetNextHop(id, sender, reversed)
	if err != nil {
		return "", xerrors.Errorf("nextHop: %v", err)
	}
	return hop, err
}

// A routing table to perform random routes.
type SocialRoutingTable struct {
	lock         sync.RWMutex
	socialProfil peer.SocialProfil
	// A source to generate the permutations.
	permutationSource *rand.Rand
	// The routing tables of the node. It corresponds to the permutations for each s-instance.
	// A route message coming from neighbor i is forwarded to the neighbor at index routingPermutations[id][i].
	routingPermutations map[uint][]uint
	// The reverse routing permutations. If x -> perm(x) in routingPermutations,
	// then perm(x) -> x in reversedRoutingPermutations.
	reversedRoutingPermutations map[uint][]uint
}

func NewSybilRoutingTable(routeSeed int64, socialProfil peer.SocialProfil) *SocialRoutingTable {
	return &SocialRoutingTable{
		socialProfil:                socialProfil,
		routingPermutations:         make(map[uint][]uint),
		permutationSource:           rand.New(rand.NewSource(routeSeed)),
		reversedRoutingPermutations: make(map[uint][]uint),
	}
}

func (s *SocialRoutingTable) Reset() {
	s.lock.Lock()
	defer s.lock.Unlock()
	s.routingPermutations = make(map[uint][]uint)
	s.reversedRoutingPermutations = make(map[uint][]uint)
}

func (s *SocialRoutingTable) GetSharedKey(neighbor string) (string, bool) {
	return s.socialProfil.GetSharedKey(neighbor)
}

// Returns a random neighbor and true if any, or false otherwise.
func (s *SocialRoutingTable) GetRandomNeighbor() (string, bool) {
	s.lock.RLock()
	defer s.lock.RUnlock()
	size := s.socialProfil.NumberOfRelation()
	if size <= 0 {
		return "", false
	}
	index := (uint)(rand.Intn((int)(size)))
	return s.socialProfil.GetRelation(index), true
}

// Add a given permutation for the s-instance with the provided id.
// It overwrite the potential present permutation.
func (s *SocialRoutingTable) addRoutingPermutation(id uint, reversed bool) []uint {
	s.lock.Lock()
	defer s.lock.Unlock()
	nbrNeighbors := s.socialProfil.NumberOfRelation()
	perm := s.permutationSource.Perm((int)(nbrNeighbors))
	permCopy := make([]uint, len(perm))
	for i, p := range perm {
		permCopy[i] = uint(p)
	}
	currentPerm, ok := s.routingPermutations[id]
	if ok {
		return currentPerm
	}
	reversePerm := make([]uint, len(perm))
	for i, v := range perm {
		reversePerm[v] = uint(i)
	}
	s.routingPermutations[id] = permCopy
	s.reversedRoutingPermutations[id] = reversePerm
	if reversed {
		return reversePerm
	}
	return permCopy
}

// Returns the next hop for the route with the provided id, when the route comes from the provided sender.
// If reversed if true, the route uses the reverse permutation.
func (s *SocialRoutingTable) GetNextHop(id uint, sender string, reversed bool) (string, error) {
	readHop := func(id uint, sender string, reversed bool) (string, bool, error) {
		s.lock.RLock()
		defer s.lock.RUnlock()
		var perm []uint
		var ok bool
		if reversed {
			perm, ok = s.reversedRoutingPermutations[id]
		} else {
			perm, ok = s.routingPermutations[id]
		}

		if ok {
			hop, err := s.nextHopWithPerm(sender, perm)
			return hop, ok, err
		}

		return "", ok, nil
	}
	nextHop, isPresent, err := readHop(id, sender, reversed)
	if err != nil {
		return "", xerrors.Errorf("GetNextHop: %v", err)
	}

	if !isPresent {
		s.lock.Lock()
		defer s.lock.Unlock()
		perm := s.addRoutingPermutation(id, reversed)
		hop, err := s.nextHopWithPerm(sender, perm)
		if err != nil {
			return "", xerrors.Errorf("GetNextHop: %v", err)
		}
		return hop, nil
	}

	return nextHop, nil
}

func (s *SocialRoutingTable) nextHopWithPerm(neighbor string, perm []uint) (string, error) {
	neighborIndex, ok := s.socialProfil.GetRelationIndex(neighbor)
	if !ok {
		return "", fmt.Errorf("neighbor %s is not a neighbor", neighbor)
	}
	nextHopIndex := perm[neighborIndex]
	return s.socialProfil.GetRelation(nextHopIndex), nil
}
